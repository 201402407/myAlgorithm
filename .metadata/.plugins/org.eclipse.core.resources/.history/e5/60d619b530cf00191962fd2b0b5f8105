package p1280;

import java.io.*;
import java.util.*;

public class p1280 {
	public static void main(String args[]) {
		Graph g = new Graph(4);

		  g.addEdge(0, 1);
		  g.addEdge(0, 2);
		  g.addEdge(1, 2);
		  g.addEdge(2, 0);
		  g.addEdge(2, 3);
		  g.addEdge(3, 3);

		  g.BFS(2); // 시작 노드로 탐색
	}
}

class Graph {
	private int vertexCount; // 노드의 개수
	private LinkedList<Integer> adjList[];
	
	Graph(int vCount) {
		vertexCount = vCount;
		adjList = new LinkedList[vCount];
		for(int i = 0; i < vCount; i++) {
			adjList[i] = new LinkedList();
		}
	}
	
	void addEdge(int vertex, int weight) {
		adjList[vertex].add(weight);
	}
	
	// DFS 탐색 함수
	String DFS(int startNode) {
		String resultDFS = "";
		Stack<Integer> stack = new Stack();
		// 방문 여부 판단 배열 생성
		Boolean[] visited = new Boolean[vertexCount];
		Arrays.fill(visited, Boolean.FALSE);
		
		stack.push(startNode);
		while(!stack.isEmpty()) {
			startNode = stack.pop();
			if(!visited[startNode]) {
				resultDFS += String.valueOf(startNode) + " ";
				System.out.print(startNode + " ");
				visited[startNode] = true;
				// 해당 노드와 인접한 모든 노드를 가져오기
				Iterator<Integer> iterator = adjList[startNode].listIterator();
				while(iterator.hasNext()) {
					int node = iterator.next();
					if(!visited[node]) {
						visited[node] = true;
						stack.push(node);
					}
				}
			}
		}
	}
	
	// BFS 탐색 함수
	String BFS(int startNode) {
		String resultBFS = "";
		// 방문 여부 판단
		Boolean[] visited = new Boolean[vertexCount];
		Arrays.fill(visited, Boolean.FALSE);
		
		// 큐 생성
		LinkedList<Integer> queue = new LinkedList<Integer>();
		// 첫 시작 노드 큐에 삽입
		visited[startNode] = true;
		queue.add(startNode);
		// 큐가 empty 까지 반복
		while(!queue.isEmpty()) {
			// 큐에서 dequeue
			startNode = queue.poll();
			resultBFS += String.valueOf(startNode) + " ";
			System.out.print(startNode + " ");
			
			// 해당 노드와 인접한 모든 노드를 가져오기
			Iterator<Integer> iterator = adjList[startNode].listIterator();
			while(iterator.hasNext()) {
				int node = iterator.next();
				if(!visited[node]) {
					visited[node] = true;
					queue.add(node);
				}
			}
		}
		return resultBFS;
	}
}
